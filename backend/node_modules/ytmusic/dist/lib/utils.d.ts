/**
 * @ignore
 */
export declare const generateBody: (args: {
    id?: string;
    type?: string;
    userID?: string;
}) => string | object;
/**
 * @ignore
 */
export declare const generateHeaders: (cookie: string, authUser?: number | undefined) => object;
/**
 * @ignore
 */
export declare const sendRequest: (c: string, args: {
    id?: string;
    type?: string;
    body?: object;
    endpoint: string;
    userID?: string;
    cToken?: string;
    itct?: string;
    authUser?: number;
}) => Promise<any>;
export declare function filterMap<T, R>(collection: T[], f: (item: T) => R | undefined | null): R[];
export declare function filterFlatMap<T, R>(collection: T[], f: (item: T) => R[] | undefined | null): R[];
/**
 * Wraps a function that accepts input T and parses it into output R.
 * In the normal case, this is a no-op; if the function throws, however,
 * we will augment the thrown Error with context bout what was being parsed.
 */
export declare function parser<T extends any[], R>(f: (...input: T) => R): (...input: T) => R;
export declare const getURLVideoID: (link: string) => string;
